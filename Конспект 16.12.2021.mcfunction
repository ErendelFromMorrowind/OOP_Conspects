                          Сложные типы данных
Массивы
Перечисления
Стурктуры

Массив — набор элементов одного и того же типа, объединённых общим именем;

            Одномерные массивы
Объявление: базовый_тип [] <имя массива>;
int[] mass;
Происходит выделение ячейки памяти. По выделению не понятно, что это будет массив;
Имя массива в С# отождествляется с адресом его начального элемента. Имя массива является ссылкой на его нулевой элемент;
Все элементы массива идут строго друг за другом. В ссылку записывается адрес нулевой ячейки массива;


Могут быть инициализированы двумя способами
{
  1. Задача полного содержимого массива;
  int[] a = {1, 7, 9, 5, 3};

  2. Задача размера массива и инициализация по умлочанию;
  int[] a = new int [5];
  По умолчанию там торчат нули. Да, это бесполезно. Да, это бесполезная информация;

  3. Совмещение обоих методов;
  int[] myMas = new int [] { 99, 10, 100, 18, 78, 23, 163, 9, 87, 49 };
  int[] myMas = new int[6];
  for (int i = 0; i < 6; i++)
  {
    myMas[i] = int.Parse(Console.ReadLine());
  }
}
//вложение "Память в массивов"

В C# строго контролируется обращение к элементу массива. При превышении границы будет ошибка;

Можно перенастраивать ссылку на массив в любой момент:
static void Main(string[]args)
{
  int[] myMas = { 0, 1, 2, 3, 4, 5 };
  Console.WriteLine("\nНовый массив:");
  myMas = new int[] { 99, 10, 100, 18, 78, 23, 163, 9, 87, 49};
  for (i = 0; i < 10; i++)
  {
    Console.Write(" " + myMas[i]);
  }
}

Фактически при создании нового массива с тем же именем адрес ссылки меняется, а старый массив остаётся занимать память;
Он не исчезнет до очистки памяти;


Свойство Length. Возвращает длину массива;
int[] myArr = { 1, 2, 3, 4};
for (int i = 0; i < myArr.Length; i++)
{
  //code;
}


Цикл foreach;
foreach (<тип_массива> <temprary> in <имя_массива>)
{
  <тело_цикла>;
}

Задаётся временная переменная такого же типа, как и массив. В переменной поочерёдно сохраняются элепменты массива;

int[] myArr = { 1, 2, 3, 4, };
foreach (int x in myArr)
{
  Console.WriteLine("{0}", x);
}
foreach работает намного быстрее, чем for;
С его помощью нельзя изменять значения массива, а только просматривать их;


Console.Write("\n mas[{0}] = ", i);
Mas[i] = ConvertToInt32(Console.ReadLine());
//правило вежливости. Удобно видеть номер вводимого элемента;




            Массив как параметр функции
static void print(int[] a)  //n — размерность массива, а — ссылка на массив;
{

}

Вызов:
static void Main(string[]args)
{
  Print(myArray);
}


Особенности передачи массива в функцию
{
  1. Если массив является аргументом функции, ref'a нету;
      Исключение:
  2. В функцию достаточно передавать только сам массив. Всё остальное можно определить и так;
  3. Функция может возвращать массив в качестве результата — нужно просто вернуть ссылку. Вернётся ссылка на массив;
  int[] mas = new int[N];
  return mas;
}



          Массив как тип возвращаемого значения
static int[] inputArray()
{
  //тело функции
  int[] array = new int N[];
  return array;
}

static void Main(string[]args)
{
  int[] mas = inputArray();
}



                Возвращение значений и параметры функции Main()
Варианты шапки:
{
  1. static void Main()
  2. static void Main(string[] args)
  3. static int Main()
  4. static int Main(string[args])
}

На выход в Main'e можно отправлять результат завершения программы — 0 или 1;


          Функции с переменным числом параметров
Функции, у которых перед параметром стоит служебное слово params;
Такой параметр может быть только один. Он позволяет варьировать количество параметров одного и того же типа;
static int Calculate(int a, ref int b, out int c, params int[] d)

static int Sum_Val(params int[] a)
static void Main(string[] args)
{
  int sum =  Sum_Val(1,5,8,0,2);
}
